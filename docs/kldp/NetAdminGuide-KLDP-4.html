<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> The Network Administrator's Guide V0.4: Setting up the Serial Hardware</TITLE>
 <LINK HREF="NetAdminGuide-KLDP-5.html" REL=next>
 <LINK HREF="NetAdminGuide-KLDP-3.html" REL=previous>
 <LINK HREF="NetAdminGuide-KLDP.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="NetAdminGuide-KLDP-5.html">다음</A>
<A HREF="NetAdminGuide-KLDP-3.html">이전</A>
<A HREF="NetAdminGuide-KLDP.html#toc4">차례</A>
<HR>
<H2><A NAME="s4">4. Setting up the Serial Hardware</A></H2>

<P>netland에 사는 몇몇 사람들은 T1 인터넷 링크에 돈을 소비하지 않고, 자신의 PC에 정성을
쏟는다는 유머가 있다. 그럼에도  불구하고, 매일 뉴스와  메일을 받기 위해서,  SLIP 링크,
UUCP 네트워크, 공용 전화망을 사용하는 전자게시판 시스템에 의존한다고 말하고 있다.
<P>이 장에서는 그러한 연결을 유지하기 위해 모뎀에 의존하는 모든 사람들에게 필요한 정
보를 가져다 줄 것이다. 하지만 이장에서 그러한 모든 정보를 가져다 줄 수 있는 것은 아니
다. 이를테면, 여러분의 모뎀을  다이얼인 방식으로 구현하는 방법같은  것들... 이러한 모든
화제들은 Greg Hankings. - <EM>그의 주소는 gregh@cc.gatech.edu이다.</EM> 가 쓴
Serial HOWTO에 기록되어 있을 것이며, 정기적으로 comp.os.linux.announce에 포스팅된다.
<P>
<H2><A NAME="ss4.1">4.1 Communication Software for Modem Links</A>
</H2>

<P>리눅스에서 유용하게  사용할 수 있는 몇가지 통신 패키지가 있다. 이것들 대부분이
<EM>terminal program</EM>이라고 하는 것인데, 이것은 사용자가 다른 컴퓨터에 접속하는 것을
도와
준다. 일반적으로 사용하는 터미널 프로그램으로는 kermit가 있다. 전화번호부와 원격 컴퓨
터 시스템에 접속하거나 전화를 걸어주는 스크립트 언어를 제공해주는 더욱더 안정되고, 유
용한 프로그램들이 얼마든지 있다. 그것들 중에 하나가 minicom이라는 것이 있는데, 이것은
도스에 길들어져 있는 사용자들이 터미널 프로그램을 사용할 수 있게 도와준다. 이러한 프
로그램들 중 <EM>seyon</EM>이라고 하는 X윈도우용 통신 패키지도 있다.
<P>리눅스용 BBS 패키지들 또한 전자게시판을 구현하려는 많은 사람들에게 도움을 주고
있다. 이러한 패키지 중 일부는 sunsite.unc.edu사이트의 /pub/Linux/system/Network 디
렉토리에서 찾을 수 있다.
<P>터미널 프로그램과는 다르게 여러분의 컴퓨터에서 다른 곳으로 데이터를 전송하기  위해
대화식 시리얼 링크를 사용하는 소프트웨어도  있다. 이 기술을 사용해서 얻는  이점이라면,
몇 수십 킬로바이트 크기의 데이터를 전송받을 때, 이를테면, 메일박스에 있는 온라인  메일
을 받을때나, 게시판에서 재미있는 글을 읽을 때의 시간을 좀더 줄일 수 있다는 것이다.  다
른 한편으로, 여러분이 받는 정보를 적재하지 않기 때문에 더욱더 많은 디스크 공간을 필요
로 한다.
<P>이러한 종류의 전형적인 통신 소프트웨어라고 한다면, 그것은 바로  UUCP일 것이다. 이
것은 이쪽 호스트에서 저쪽 호스트로 파일을 복사할 때나,  원격 호스트에서 프로그램을 실
행시키고자 할 때, 적합한 프로그램이다. 이것은 대개 개개인의 네트워크에서 뉴스나 메일을
받을 때 자주 사용한다. 리눅스에서 실행할 수 있는 Ian Taylor의 UUCP 패키지는 다음 장
에서 설명하겠다.  비대화식 통신  소프트웨어는 Fidonet를  거쳐  사용된다. ifmail과  같은
Fidonet 어플리케이션 포트또한 유용하게 사용할 수 있다.
<P>SLIP, <EM>serial line Internet protocol</EM>은 대화식 (interactive)과 비대화식 프로그램사이에
서
중간 매개 역할을 한다. 많은 사람들이 그들의 대학망을  다이얼업하거나 FTP 세션을 구현
하기 위해 일반적으로 사용하는 공용 SLIP 서버를 위해 SLIP를 사용한다. SLIP은 또한 영
구적으로나 반영구적인 연결방법으로 LAN-to-LAN 커플링을 위해 사용하기도 하며, ISDN
에서도 사용한다.
<P>
<H2><A NAME="ss4.2">4.2 Introduction to Serial Devices</A>
</H2>

<P>시리얼 장치를 엑세스하기 위해 제공되는  유닉스 커널 장치를 tty, <EM>TeletypeTM</EM>이라
고 부른
다. 이것은 초기 유닉스 시절에 터미널 제조 업체중 한군데에서 사용했다. 현재는 문자로 데
이터를 처리하는 터미널 형태로 사용하고 있다.  이 장을 통해서, 우리는 커널 장치에  대한
용어를 정립해 나갈 것이다.
<P>리눅스 배포본에는 세가지 형태의  tty: (가상) 콘솔,  pseudo(의사)-터미널 (X11과 같은
어플리케이션으로 사용하는 two-way 파이프와 유사하다.) 그리고 시리얼 장치를 사용한다.
맨 마지막것도 시리얼 연결을 통해서 대화식 세션을 수행하기  때문에 이것도 tty에 포함시
킨다: 이것은 터미널 라인을 통한 하드 와이어드 터미널이나  리모트 컴퓨터에서 유래한 것
이다.
<P>Tty는 구성 변수값을 가지고 있으며, 이것은 ioctl(2)  시스템 콜을 사용하도록 설정되어
있다. 이것들 중 다수의 tty는 여러 가지 형태의 연결을 처리하기 위해 더욱더 유연하게 다
룰 필요가 있은 후로, 오직 시리얼 장치에 맞추어져 있다.
<P>가장 특이할 만한 라인 변수에는 라인 속도와 패리티를 들 수 있다. 그리고, 대문자와 소
문자를 변환시켜주는 옵션과 개행문자 (line feed)로 바꾸어주는 옵션도 있다. 또한 tty 드라
이버는 line discipline를 지원해 주는데,  이것은 완전히 다르게 동작하는  장치 드라이버를
만들 때 사용한다. 예를 들어, 리눅스에서 사용하는 SLIP 드라이버를 line discipline로 사용
하기도 한다.
<P>라인의 속도를 측정할 때 사용하는 비트가 있다. 올바른 용어는 Bit rate라고 하는데, 이
것은 라인의 전송 속도를 의미하며, 초당  전송되는 비트수 (bps)를 말하는 것이다. 때때로,
여러분은 사람들에게 Baud rate라고 하는 말을 들었을 것이다. 이것은 그다지 올바른  용어
는 아니다. 이러한 두가지 형태의 용어는 절대 바꾸어서 말할 수 없다. Baud rate라는 말은
몇몇 시리얼 장치의 물리적인 특성을 말하는 것이며, 주로  전송되는 펄스의 클럭수를 말하
는 것이다. Bit rate는  두지점간에 존재하는 시리얼 연결의  현재 상태를 의미하는 것이며,
주로 초당 전송되는 평균 비트  수를 가리킨다. 전기적인 펄스가 발생할  때 생성되는 하나
이상의 비트를 인코드 시키는 대부분의 장치에서는 이 두가지 용어가 다르게 사용된다는 것
을 아는 것은 매우 중요하다.
<P>
<H2><A NAME="ss4.3">4.3 Accessing Serial Devices</A>
</H2>

<P>유닉스에서 사용하는 모든 장치와  유사하게, 시리얼 포드또한 특별한  장치 파일을 통해서
엑세스할 수 있다. 그 장치 파일은 /dev  디렉토리에 위치해 있다. 이 장치파일들은 시리얼
드라이버와 각 포트에 연관되어 있는 장치파일의 두가지 양상을  띄고 있다. 이러한 파일에
의존하고 있는 장치들은 완전히 다르게 동작할 것이다.
<P>첫 번째 장치파일은 포트를 통해서 다이얼링인을 할 때마다 사용한다; 네 개의 주번호를
사용하며, 그 이름은 ttyS0, ttyS1등이 있다. 두  번째 장치 파일은 포트를 통해서 다이얼링
아
웃을 할 때 사용되며, 파일 이름은 cua0, cua1을 사용한다. 다섯 개의 주번호를 사용한다.
<P>만약 여러분이 COM1에서 COM4 포트중 하나를 사용한다면, 부 번호는 COM 포트번호
에 63을 더한 값이 될 것이다. 만약 이와 다르게 설정해 놓았거나, 다중 시리얼 라인을 지원
하는 보드를 사용하고 있다면, Serial HOWTO를 읽어보기 바란다.
<P>여러분이 모뎀을 COM2에 맞추어 놓았다고  가정하자. 부번호는 65가 될것이며, 주번호
는 다이얼링 아웃을 위해 5를 사용할 것이며, 장치로는 cua1을 사용해야 한다. /dev 디렉토
리에 시리얼 tty목록이 있다. 다섯 번째와 여섯 번째  칸은 각각의 주 번호와 부 번호를 보
여주는 것이다.
<PRE>
     $ ls -l /dev/cua*
     crw-rw-rw-   1 root        5,   64 Nov 30 19:31 /dev/cua0
     crw-rw-rw-   1 root        5,   65 Nov 30 22:08 /dev/cua1
     crw-rw-rw-   1 root        5,   66 Oct 28 11:56 /dev/cua2
     crw-rw-rw-   1 root        5,   67 Mar 19  1992 /dev/cua3
</PRE>
<P>이러한 것들이 아무것도 없다면, 루트로 접속해서, 이러한 것을 만들어 주어야 한다
<PRE>
     # mknod -m 666 /dev/cua1 c 5 65
     # chown root.root /dev/cua1
</PRE>
<P>어떤 사람들은 사용자들이 모뎀이 위치한 포트가 cua1이라는 것을 기억하지 않아도 되
도록 /dev/modem에 심볼릭 링크를 만들기를 권하기도  한다. 그러나 어떤 프로그램에서는
이 modem이라는 장치를 사용할 수 없고, 실제 장치명을 사용해야  하는 경우도 있다. 이러
한 프로그램들은 그 장치가 사용하는 신호에 이른바 lock files라는 것을 사용하기 때문이다.
관례에 따르면, cua1을 사용하는 잠금 파일은 LCK...cua1이 된다. 같은 포트를 대해 다른 장
치 파일을 사용한다는 것은 프로그램들이 각각의 다른  lock file들을 인식하지 못하고 있으
며, 동시에 장치 파일들을  사용한다는 의미이다. 결과적으로  보면, 어플리케이션들은 전혀
작동하지 않을 것이다.
<P>
<H2><A NAME="ss4.4">4.4 Serial Hardware</A>
</H2>

<P>현재 리눅스에서는 RS-232를 표준으로 사용하는 거의 모든 시리얼 보드를 지원해  주고 있
다. RS-232는 현재 PC 시장에서 사용되는 모든 시리얼 통신의 표준 규격이다. 이것은 단독
비트 전송 뿐만아니라 비트 동기를 위한 몇몇 회로들을  사용한다. 추가로 사용되는 라인들
은 모뎀에서 사용하는 반송파와 handshake의 존재 유무를 나타내주기 위한 것이다.
<P>비록 하드웨어 handshake를 임의로  사용하는 것이지만, 매우 유용하게  쓰인다. 이것은
데이터를 받을 준비가 되어 있는지를 나타내 주는 상태와 수신자가 들어오는 데이터를 처리
할때까지 잠시 멈추어  있어야 하는  상태가 있다.  이러한 상태를  각각 "Clear  to Send"
(CTS) 와 "Ready to Send" (RTS)라고 부르며, 일반적으로 하드웨어 handshake 로써, 주로
"RTS/CTS"라고 부른다.
<P>PC에서, RS-232 인터페이스는 대개 National Semiconductor 16450 칩 또는 이것의 새로
운 버전인 NSC 16550A. - <EM>NSC 16550이라는 것도 있지만, 이것의 FIFO는  절대 작동
하지 않는다.</EM>에서 유래한 UART 칩을 사용한다. 몇몇 제품들 (Rockwell 칩셋을
사용하는 대부분의 내장형 모뎀)은 완전히 다른 칩을 사용하고 있으며, 그 칩은 마치 16550
인 것처럼 작동하도록 프로그램되어 있다.
<P>16450칩과 16550칩의 주요 차이점이라고 한다면, 후자는 16 바이트 FIFO 버퍼를 가지고
있는 반면, 전자는 단지 1  바이트 버퍼를 가지고 있다는  것이다. 즉 16450칩은 최고  속도
9600 보드에 적합하게 만들어져 있는 반면, 16550 호환 칩은 그 이상의 속도를 필요로 한다.
리눅스는 원래 UART 칩이였던  8250 칩도 지원한다.
<P>커널이 기본 환경설정을 할 때, COM1에서 COM4까지  네 개의 표준 시리얼 포트를 확
인한다. 이전에 설명했듯이 이 포트들은 부번호 64에서 67까지의 장치를 할당받을 것이다.
<P>여러분이 시리얼 포트를  적절하게 구성하려  한다면, rc.serial  스크립트에 Ted Tso의
setserial 명령을 설치해야 한다. 시스템 부팅시에 이  스크립트는 /etc/rc를 호출할 것이다.
전형적인 rc.serial 스크립트는 다음과 같다:
<PRE>
     # /etc/rc.serial - serial line configuration script.
     #
     # Do wild interrupt detection
     /sbin/setserial -W /dev/cua*

     # Configure serial devices
     /sbin/setserial /dev/cua0 auto_irq skip_test autoconfig
     /sbin/setserial /dev/cua1 auto_irq skip_test autoconfig
     /sbin/setserial /dev/cua2 auto_irq skip_test autoconfig
     /sbin/setserial /dev/cua3 auto_irq skip_test autoconfig

     # Display serial device configuration
     /sbin/netserial -bg /dev/cua*
</PRE>
<P>각 변수에 대한 설명을 알고 싶다면, setserial에 함께 따라오는 문서를 읽어보기 바란다.
<P>만약 여러분의 시리얼 카드가 감지되지 않았거나,  <EM>setserial -bg</EM> 명령어가 잘못된 설
정을
화면에 출력한다면, 여러분이 직접 그 구성환경을 설정해 주어야 한다. Rockwell(라겔) 칩셋
을 가지고 있는 내장형 모뎀을 사용하는 사용자들이 이 문제에 대해 보고해 주었다. 예를들
어 UART 칩이 NSC 16450으로 보고되었다면, 사실 그것은 NSC 16550 호환칩이다. 여기서
여러분은 다음과 같이 구성 명령을 바꾸어 주어야 한다.
<PRE>
     /sbin/setserial /dev/cua1 auto_irq skip_test autoconfig uart 16550
</PRE>
<P>COM 포트, 베이스 어드레스 그리고 IRQ 설정을 변경하는 옵션도 이와 유사하다. 이것
에 대해서는 setserial(8) 매뉴얼 페이지를 참고하기 바란다.
<P>여러분의 모뎀이 하드웨어 핸드셰이크를 지원하고 있다면,  그것이 사용가능한지를 확인
해야 한다. 대부분의 통신 프로그램들은 이것을 사용가능하게 만들어 주지 않는다. 꼭  여러
분이 수동으로 설정해 주어야 한다.  stty 명령을 사용하면, rc.serial 스크립트에서  가장 잘
수행된다:
<PRE>
     $ stty srtscts &lt; /dev/cua1
</PRE>
<P>하드웨어 핸드셰이크를 효과적으로 검사하기 위해서는 다음과 같이 설정해 주어라.
<PRE>
     $ stty -a &lt; /dev/dua1
</PRE>
<P>이것은 여러분에게 장치를 위한 모든 옵션을 보여줄 것이다; 옵션앞에는 꼭 '-'를 붙여
준다. 예를 들어 -crtscts옵션은 그것이 꺼져있다는 것을 의미한다.
<P>
<HR>
<A HREF="NetAdminGuide-KLDP-5.html">다음</A>
<A HREF="NetAdminGuide-KLDP-3.html">이전</A>
<A HREF="NetAdminGuide-KLDP.html#toc4">차례</A>
</BODY>
</HTML>
