<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE> The Network Administrator's Guide V0.4: Configuring the Networking Hardware</TITLE>
 <LINK HREF="NetAdminGuide-KLDP-4.html" REL=next>
 <LINK HREF="NetAdminGuide-KLDP-2.html" REL=previous>
 <LINK HREF="NetAdminGuide-KLDP.html#toc3" REL=contents>
</HEAD>
<BODY>
<A HREF="NetAdminGuide-KLDP-4.html">다음</A>
<A HREF="NetAdminGuide-KLDP-2.html">이전</A>
<A HREF="NetAdminGuide-KLDP.html#toc3">차례</A>
<HR>
<H2><A NAME="s3">3. Configuring the Networking Hardware</A></H2>

<P>
<H2><A NAME="ss3.1">3.1 Devices, Drivers, and all that</A>
</H2>

<P>현재까지 우리는 네트워크 인터페이스와 일반적인  TCP/IP 개관에 대해 이야기 해  보았
다. 하지만, 하드웨어의 한 부분을 제어하는 커널에서  "Networking code"가 도대체 무슨일
을 하는지 정확히는 알지 못한다. 이러한 경우를 위해서, 이 장에서는 인터페이스와  드라이
버의 개념에 대해 다루어 볼까 한다.
<P>우선 하드웨어 그 자체를 설명할  것이다. 예를 들어, 이더넷 보드;  이것은 얇은 에폭시
수지로 이루어져 있고, 그 속에는 각 번호를 가진 많은 양의 작은 칩들로 채워져 있으며, 그
보드를 PC의 슬롯에 꽂아 넣으면 된다. 여기서는 이런식으로 장치에 대해 설명할 것이다.
<P>이더넷 보드를 사용할 수 있게 하기 위해서, 리눅스 커널에 특별한 기능(옵션) 을 표시해
두어야 한다. 그러한 특별한 방법으로 장치를 제어해 주어야 한다. 이러한 것들을 이른바 장
치 드라이버라고 한다. 예를 들어, 리눅스는 기능면에서 이더넷 보드와 유사한 종류의  장치
드라이버를 가지고 있다. 그러한 장치 드라이버는 그것의 제작자인 Donald Becker의 이름을
따서 "<EM>Becker Series Drivers</EM>"라고 부른다. 다른 예를 들어,  D-Link 드라이버라는 것
이 있는
데, 이것은 병렬 포트에 연결되어 있는 D-Link 패킷 어댑터를 처리해 준다.
<P>그런데, 장치 드라이버를 "처리한다"라는 말은 어떤 의미일까? 위에서 이더넷 보드에 대
해 설명해 놓은 부분으로 가보자. 드라이버는 어쨋든 간에, 주변장치의 내장 로직과 통신할
수 있어야 한다 : 즉, 드라이버는 보드로 명령어와 데이터를 보내야 하는 반면에, 보드는 드
라이버로 부터 받은 어떠한 데이터라도 전송받을 수 있어야 한다.
<P>PC에서의 이러한 통신은 입출력 메모리  영역에서 이루어지며, 그것은 내장 레지스터와
대응할 수 있다. 입출력 메모리는 일반적으로 레지스터의 시작 부분이나 base address에 기
술되어 있다. 이더넷 보드의 전형적인 베이스 주소는 0x300, 또는 0x360이다.
<P>
<PRE>

          그림 3.1: 장치 드라이버, 인터페이스 그리고 하드웨어와의 관계
</PRE>
<P>대개, 여러분은 베이스 주소와 같은 하드웨어 개관에 대해서는 걱정하지 않아도 된다. 왜
냐하면, 커널이 부트시간에 보드의 위치를 감지해 내기 때문이다. 이러한 것을
<EM>autoprobing</EM>이라고 부른다. 즉, 이것은 커널이 여러 메모리 위치를 읽어 들이고,
어떤 이더넷 보드가 설치되어 있는지를  그 데이터와 비교한다. 하지만, 자동으로  감지해낼
수
없는 이더넷  보드 또한 있을지도 모른다; 표준 보드와 전혀 호환성이 없는 값싼 이더넷
카드를 만들어 내는 경우이다. 그리고 나서 커널을 부팅할 때, 이더넷 장치를 감지해
내려고 시도할 것이다. 만약, 여러분이 하나 이상의 보드를 사용하고 있다면, 이러한
정보를 커널에 기술해 놓아야 한다.
<P>여러분이 커널에 기술해 놓아야 하는 또 다른 변수로는  인터럽트 요청 채널이 있다. 커
널에서는 각 하드웨어 부품에 대해 인터럽트를 매기는데, 그들  부품들은 이 인터럽트에 의
해 처리될 필요가 있는 경우가  있다. 예를 들어, 어떤 데이터가  도착할 때, 특별한 상태가
발생하기도 한다. PC에서, 인터럽트들은 0과 1 그리고 3에서  15까지 번호를 부여한 15개의
인터럽트 채널들 중 하나에서 발생한다. 하드웨어 부품들이 각각 하나씩 인터럽트번호를 가
지고 있으며,   이러한 인터럽트번호를   <EM>interrupt request   number</EM>, 또는   IRQ. -
<EM>IRQ
2와 9는 실제로 같다. 왜냐하면, PC는 각 8개의  IRQ를 가진 인터럽트 프로세서를 두줄로
직렬배열하고 있기 때문이다. 즉, 두 번째 프로세서는 첫 번째  프로세서의 IRQ 2에 연결되
어 있다.</EM>라고 부른다.
<P>2장에서 기술한대로, 커널은 이른바 인터페이스를 통해 장치(device)를 엑세스한다. 인터
페이스는 모든 종류의 하드웨어에서 데이터를 받거나 보내거나 하는 추상적인 기능을  제공
한다.
<P>인터페이스는 그 이름과 동일한 것으로 간주한다. 이러한 것들은 커널에서 정의된다. 즉,
/dev 디렉토리에 꼭 장치 파일이 있는 것은 아니다. 전형적으로  이더넷 인터페이스를 위한
이름으로는 eth0, eth1이 있다. 각 장치에 해당하는 인터페이스의  할당은 그 장치가 구성되
어 있는 순서에 따라 결정된다; 이를테면,  첫 번째로 설치되어 있는 이더넷  보드는 eth0이
될것이고, 다음것은 eth1으로  이름지어 질  것이다. 이러한  규칙들 중 물론  예외도 있다.
SLIP 인터페이스는 동적으로 할당된다. 다시 말해서, SLIP 연결이 확립될 때, 인터페이스가
시리얼 포트에 할당된다.
<P>그림 3.1에서 우리는 하드웨어, 장치 드라이버  그리고 인터페이스간의 관계를 볼 수  있다.
<P>부팅할 때, 커널이 감지하는 장치와 설치되어 있는 인터페이스가 화면에 나타난다.  다음
예는 우리가 흔히 볼 수 있는 부트 화면이다.
<PRE>
     .
     .
    This processor honours the WP bit even when in supervisor mode. Good.
    Floppy drive(s): fd0 is 1.44M
    Swansea University Computer Society NET3.010
    IP Protocols: ICMP, UDP, TCP
    PPP: version 0.2.1 (4 channels) OPTIMIZE_FLAGS
    TCP compression code copyright 1989 Regents of the University of California
    dl0: D-Link DE-600 pocket adapter, Ethernet Address: 00:80:C8:71:76:95
    Checking 386/387 coupling... Ok, fpu using exception 16 error reporting.
    Linux version 1.1.11 (okir@monad) #3 Sat May 7 14:57:18 MET DST 1994
</PRE>
<P>지금 이것은 커널에서 TCP/IP 와 SLIP, CSLIP 그리고 PPP를 사용가능하게 컴파일하는 과
정의 일부분이다. 밑에서 세 번째  행은 D-Link 포켓 어댑터가 감지되었고,  설치되어 있는
인터페이스는 dl0라는 것을 말해준다. 만약 여러분이 다른 종류의 이더넷 카드를 가지고 있
다면, 커널은 대개 그 종류에 해당하는 카드를 감지해서, eth0  라는 인터페이스를 시작시키
는 행을 출력해 줄 것이다. 만약 여러분이 현재 설치되어  있는 이더넷 카드를 가지고 있다
면, 어떤 메시지도 볼 수 없다. 즉 이것은 커널이 여러분의 보드를 감지해낼 수 없다는 것을
뜻한다. 이것에 대해서는 다음절에서 상세히 다루겠다.
<P>
<H2><A NAME="ss3.2">3.2 Kernel Configuration</A>
</H2>

<P>대부분의 리눅스 배포본에서는 모든 일반적인 종류의 PC 하드웨어를 구동시켜  주는 부트
디스크를 가지고 있다. 이것은 그 부트 디스크에서 커널이  모든 일반적인 종류의 드라이버
를 가지고 있다는 것을 의미한다. 그러나  커널이 그 부분을 스왑 아웃 할  수 없기 때문에
이전의 시스템 메모리를 소비하게 된다. 그러므로, 여러분은 실제로 필요로 하고, 원하는 드
라이버만 포함시켜서 커널을 구성해야 한다.
<P>리눅스 시스템을 구동시킬 때, 여러분은 꼭 자기가 만들고 있는 커널을 잘 알고 있어야
한다. 이것에 대해 기본적으로 설명하고 있는 문서로는 Matt  Welsh가 쓴 "
<EM>Installation and Getting Started</EM>"가 있다. 이것도 또한
<EM>Linux Documentation Project</EM> (LDP) 시리즈중 하나 이다. 이 절에서,
우리는 네트워킹과 관련되어 있는 구성 옵션만을 다룰 것이다.
<P>여러분이 make config를 실행하기에 앞서, 일반적인  구성에대해 답해야 할 것이다. 이
를테면, 여러분이 커널의 수치연산 프로세서를 원하고 있는지 아닌지... 이러한 것들중  하나
로써, TCP/IP 네트워킹을 원하는지도 답해야  한다. 실제로 네트워킹을 하고  싶다면 'y'를
입력해야 한다.
<P>
<H3>Kernel Options in Linux 1.0 and Higher</H3>

<P>일반적인 옵션에 대한 답변을 완성한 후에, SCSI  드라이버와 같은 여러 가지 전반적인 형
태에 대한 질문에 답변해야 한다. 다음에  보이는 것은 네트워킹 지원에 관한 질문이다.  이
구성옵션에 관한 세부 항목들은 이 질문이 끝난후 계속해서  나타날 것이며, 이러한 질문도
커널이 발전해 감에 따라 더  늘어날 것이다. 지금 보이는  것은 대부분의 커널 버전  1.0과
1.1에서 제공되는 옵션이다. (그에 관한 주석문은 이탤릭체로 나타낸다.);
<PRE>
     *
     * Network device support
     *
     Network device support? (CONFIG_ETHERCARDS) [y]
</PRE>
<P>꺽쇠 묶음([])에서 나타난 매크로 이름은 무시해 버려라. 여러분이 어떤 형태의 네트워킹 장
치 즉, 이더넷, SLIP 또는 PPP를 사용하고자 한다면, 이 질문에 'y'라고 답해야 한다. 이 질
문에 'y'라고 답했다면, 자동으로 이더넷 류의 장치를 지원하게 된다. 다른 형태의 네트워크
드라이버를 지원하고자 한다면, 개별적으로 선택해야 한다.
<PRE>
     SLIP (serial line) support? (CONFIG_SLIP) [y]
      SLIP compressed headers (SL_COMPRESSED) [y]
     PPP (point-to-point) support? (CONFIG_PPP) [y]
     PLIP (parallel port) support? (CONFIG_PLIP) [n]
</PRE>
<P>이러한 질문에 답변하려면 적어도 리눅스에서 제공하는 여러 가지 프로토콜에 대해서 약
간의 지식은 알고 있어야 한다. SLIP은  시리얼 라인을 통해서 IP 데이터 그램을  전송하는
것이다. compressed headers 옵션은 CSLIP을 위한 지원사항을 물어보는 것인데, 이 CSLIP
는 TCP/IP 헤더를 적어도 세바이트로 압축하는 기술을 말한다.
이 커널옵션이 자동으로 CSLIP을 지원해 주는 것이 아님을 기억하라. 대개 이것을 위해 특
별한 커널 기능을 필요로 한다.
<P>PPP는 시리얼 라인을 통해서 네트워크 트래픽을 보내주는 또 다른  프로토콜이다. SLIP
보다 약간더 다루기 쉽고, IP에 제한되어 있지 않으며, 그것이 수행될 때,  IPX를 지원해 준
다. 최근에 들어와서 이 PPP 옵션을 제공해 주고 있지만, 이 커널에서는 아직 이 옵션이 없
다.
<P>PLIP는 패러랠 포트와의 연결을 통해서 IP 데이터 그램을 보내주는 방법을 제공한다. 이
것은 대개 DOS를 실행하고 있는 PC와 통신하기 위해서 사용한다.
<P>다음 질문은 여러 컴퓨터 회사에서 만들어낸 이더넷 보드에 관한 질문들이다. 더욱더 많
은 드라이버가 개발되고 있다. 만약  여러분이 여러 다른 기계에서 사용할  수 있는 커널을
만들고자 한다면, 하나이상의 드라이버를 선택할 수 있다.
<PRE>
     NE2000/NE1000 support (CONFIG_NE2000) [y]
     WD80*3 support (CONFIG_WD80x3) [n]
     SMC Ultra support (CONFIG_ULTRA) [n]
     3c501 support (CONFIG_EL1) [n]
     3c503 support (CONFIG_EL2) [n]
     3c509/3c579 support (CONFIG_EL3) [n]
     HP PCLAN support (CONFIG_HPLAN) [n]
     AT1500 and NE2100 (LANCE and PCnet-ISA) support (CONFIG_LANCE) [n]
     AT1700 support (CONFIG_AT1700) [n]
     DEPCA support (CONFIG_DEPCA) [n]
     D-Link DE600 pocket adaptor support (CONFIG_DE600) [y]
     AT-LAN-TEC/RealTek pocket adaptor support (CONFIG_ATP) [n]
     *
     * CD-ROM drivers
     *
     ...
</PRE>
<P>파일 시스템 절(section)에서, 마지막으로, 환경 구성  스크립트는 여러분에게 NFS, 네트
워킹 파일시스템을 지원할 것인지를 물어볼 것이다. NFS는 파일시스템을 여러 호스트로 보
내주는 역할을 한다. 꼭 그것이 호스트에 붙어 있는 임시  하드 디스크 인것처럼 파일을 보
여 준다.
<PRE>
     NFS filesystem support (CONFIG_NFS_Fs) [y]
</PRE>
<P>
<H3>Kernel Options in Linux 1.1.14 and Higher</H3>

<P>리눅스 1.1.14에서는 약간의 구성환경을 바꾸었으며,  IPX 지원을 추가시켰다. 다음절에서는
여러분이 원하는 일반적인 네트워킹 옵션을 물어볼 것이다. 이것은  여러 가지 네트워킹 옵
션에 관한 질문을 말한다.
<PRE>
     *
     * Networking options
     *
     TCP/IP networking (CONFIG_TNET) [y]
</PRE>
<P>여러분이 TCP/IP 네트워킹을 사용한다면, 이 질문에 'y'라고  답해야 한다. 그렇지 않고 'n'이라고 답했다 하더라도, IPX를 지원하는 커널을 컴파일할 수 있다.
<PRE>
     IP forwarding/gatewaying (CONFIG_FORWARD) [n]
</PRE>
<P>두 개의 이더넷이나 이더넷과 SLIP 링크사이에서 여러분의 시스템을 게이트웨이로써 사
용하고 있다면, 이 옵션을 사용할 수  있다. 이 옵션을 초기값대로 사용하지 않는다  하더라
도, 이른바 방화벽으로 호스트를 구성하고 싶어할 지도 모른다. 방화벽은 두 대 이상의 네트
워크에 연결되어 있는 호스트이지만, 그  네트워크 사이에서 라우트 트래픽을 하진  않는다.
방화벽은 대개 내부망에서 위험부담을 느끼고 있는 회사망으로부터 사용자들을  보호하는데
에 사용된다. 사용자들은 방화벽에  접속해서, 인터넷 서비스를  사용하지만, 그 회사망으로
들어오는 어떤 연결도 방화벽에 접근할 수 없기 때문에, 외부 공격으로부터 그 회사의 기계
를 보호할 수 있다.
<PRE>
     *
     * (it is saft to leave these untouched)
     *
     PC/TCP compatibility mode (CONFIG_INET_PCTCP) [n]
</PRE>
<P>이 옵션은 몇몇 PC/TCP버전과, DOS를 기초로하는  PC에서, 구동하는 상업용 TCP/IP와는
비호환적으로 작동한다. 만약 여러분이 이  옵션을 사용한다면, 일반적으로 사용하는 UNIX
기계와 통신할 수 있지만, 그 기계에 연결하는 속도는 느려지게 될지도 모른다.
<PRE>
     Reverse ARP (CONFIG_INET_RARP) [n]
</PRE>
<P>이 기능은 RARP, <EM>Reverse Address Resolution Protocol</EM>을 사용할 수 있게 해준다.
RARP는 디스크없는 클라이언트와 부팅할 때, IP 어드레스를 필요로하는 X 터미널에 사용
된다. 여러분이 몇몇 클라이언트를 제공할 계획이라면,  RARP를 사용해야 한다. 최근에 나
온 네트워크 패키지들 (net-0.32d)은 rarp라고 하는 작은 유틸리티를  포함하고 있다. 이 유
틸리티로 시스템을 RARP 캐쉬에 추가시킬 수 있다.
<PRE>
     Assume subnets are local (CONFIG_INET_SNARL) [y]
</PRE>
<P>TCP를 통해서 데이터를 보낼 때, 데이터가 IP로 들어가기 전에, 커널은 여러패킷의 흐름을
중단시켜야 한다. 호스트를 위해서는 이더넷과 같은 로컬 네트워크를 통해서 데이터를 보낼
수있으며, 그 호스트는 먼거리에서 들어오는 데이터나 거대한 패킷또한  사용할 수 있을 것
이다.{{. 이것은 매우 작은 최대 패킷크기의 분열을 피하기 위한 방법이다.
}} 만얀 여러분이 SNARL을  사용하지 않는다면, 커널은  그들의 네트워크들이 실제로
하나의 인터페이스를 가지고 있는 로컬네트워크라고 가정할  것이다. 그럼에도 불구하고 여
러분이 Groucho Marx University에 있는 클래스 B 네트워크를 찾고자 한다면, 클래스 B의
전체네트워크가 로컬이 되지만, 대부분의 호스트들의 인터페이스는 단지 하나이상의 서브넷
만을 가질 것이다. 만약 여러분이 SNARL을 사용한다면, 커널은 모든 서브넷이 로컬이라고
가정할 것이며, 대학에 있는 모든호스트와 통신할 때, 거대한 패킷을 사용하게 될 것이다.
<P>만약 여러분이 특별한 호스트에 보내는 데이터를 위해서 조그마한 패킷을 사용하고자 한
다면, (이를테면, SLIP연결을 통해 데이터를 보내고자 하는  경우) 여러분은 route에 mtu옵
션을 사용해서, 그 문제를 해결할 수 있다. 이것에 대해서는 이장의 맨끝부분에서 거론할 것
이다.
<PRE>
     Disable NAGLE algorithm (normally enabled) (CONFIG_TCP_NAGLE_OFF) [n]
</PRE>

Nagle는 이른바 tinygrams라고 부르는 특별하게 보내는 작은  IP 패킷을 피하기위한 규
칙이다. 대화식 네트워킹 툴이 이러한  tinygram을 만들어 내는데, telnet  또는 rsh와 같은
네트워킹 툴로 이러한 tinygram을 보낸다. SLIP과 같은  저 대역폭 연결에서는 tinygram을
파과할 수 있다. Nagel 알고리즘은 어떤 상황하에서 발생하는 데이터를 TCP 전송층으로 걷
어들이는 작업을  할 것이다.  만약  여러분이 전송도중  패킷을 잃어버릴  염려가  있다면,
Nagle 알고리즘을 사용하지 않을 수도 있다.
<PRE>
     The IPX protocol (CONFIG_IPX) [n]
</PRE>

이 옵션은 노벨 네트워킹에서 사용하는  전송프로토콜인 IPX를 사용할 수 있게  해준다.
이것은 여전히 개발중에 있고, 아직 실제로는 사용할 수 없다. 이것을 사용하는 한가지 이점
이라면, 언젠가는 여러분이  IPX를 기반으로하고  있는 DOS  유틸리티를 사용할 수  있고,
PPP 연결을 통해서, 노벨에  기초를 두고 있는 네트워크에서  라우트 트래픽이 가능하다는
것이다. 노벨 네트워킹에서 고급 프로토콜을  지원할 날이 그다지 가깝지만은 않지만,  현재
소비되는 끔직한 많은 양의 비용을 생각해 보면, 반가운 소식중의 하나일 것이다.
<P>1.1.16 커널에서, 리눅스는 또 다른 종류의 드라이버와  더미 드라이버를 지원해 주고 있
다. 다음 질문은 장치 드라이버를 사용할 것인지를 물어보는 질문이다.
<PRE>
     Dummy net driver support (CONFIG_DUMMY) [y]
</PRE>

더미 드라이버를 사용하는 사람이 그다지 많지는 않지만, 스탠드얼론이나 SLIP 호스트에
서는 매우 유용하게 사용할 수 있다. 이것은 기본적으로 루프백 인터페이스를 매스커레이드
한 것이다. 루프백 인터페이스를 사용하는 이유는 이더넷에서가 아닌 SLIP을 사용하는 호스
트에서 구동하기 때문이며, 이것은 항상 여러분의 IP 어드레스를 유지시키는데에 도움을 준
다. 더미 인터페이스에 관한 더 자세한 것은 5장에서 다루것이다.
<P>
<H2><A NAME="ss3.3">3.3 A Tour of Linux Network Devices</A>
</H2>

<P>리눅스 커널은 여러형태의 장비를 위해서 많은 하드웨어 드라이버를  지원해 준다. 이 절에
서는 흔히 볼 수 있는 드라이버와 그것에 해당하는 인터페이스에 대해 간략히 설명하겠다.
<P>리눅스에서는 표준으로 사용하는 인터페이스가 몇몇있다. 하나이상의 인터페이스를 지원
하는 대부분의 드라이버는 그 인터페이스 이름이  eth0, eth1과 같이 각각에 번호를 부여하
고 있다.
<DL>
<DT><B>lo</B><DD><P>로컬 루프백 인터페이스. 네트워크 어플리케이션 뿐만아니라 시험용 목적으로
사용된다. 어떤 경우 즉, 만들어진 데이터그램이 즉시 호스트의 네트워킹층으로 되돌아
오는 경우에는 마치 폐쇠회로와 같이 작동한다. 커널에는 항상 적어도 하나 이상의
루프백 장치가 나타나 있다.
<DT><B>ethn</B><DD><P>n번째 이더넷 카드. 대부분의 이더넷 보드에서  사용하는 일반적인 인터페이스의
이름.
<DT><B>dln</B><DD><P>이 인터페이스는 D-Link DE-600 포켓 어댑터와, 또 다른 이더넷 장치를 엑세스한
다.
이것은 패러랠 포트를 통해 구동하는 DE-600에서만은 특별하게 사용된다.
<DT><B>sln</B><DD><P>n번째 SLIP 인터페이스. SLIP 인터페이스는 SLIP에 할당하는 시리얼 라인의
순서와 연관시켜서 생각해 볼 수 있다. 즉, SLIP을 구성하고 있는 첫 번째 시리얼 라인은
<B>sl0</B>가 된다. 커널은 최고 네 개의 SLIP 인터페이스를 지원해 준다.
<DT><B>plipn</B><DD><P>n번째 PLIP 인터페이스. PLIP는 패러랠 라인을 통해서 IP 데이터 그램을 전송한
다.
커널에서는 최고 세 개까지 PLIP 인터페이스를 제공해  주고 있다. 이 인터페이스는
시스템이 부팅할 때, PLIP 드라이버에  할당되며, 패러 포트에 대응된다.
</DL>
<P>ISDN 또는 AX.25와 같은 인터페이스 드라이버들은 미래에 추가될지도 모른다. IPX (노
벨 네트워킹 프로토콜)과 AX.25 (ham radio amateurs에서 사용됨)를 위한 드라이버들은 현
재 개발중에 있으나 아직 초기 단계에 머물러 있다.
<P>다음 절에서 우리는 위에서 기술한 드라이버 사용에 관한 자세한 정보를 다룰 것이다.
<P>
<H2><A NAME="ss3.4">3.4 Ethernet Installation</A>
</H2>

<P>현재 리눅스 네트워크 코드는 여러  가지 이더넷 카드 상표를 지원해  주고 있다. 대부분의
드라이버는 Donald Becker (becker@cesdis.gsfc.nasa.gov)에 의해  만들어 지고 있다. 그
는 National Semiconductor 8390 chip을 사용하는 카드를 위한 드라이버를 만들어낸 사람이
다. 이 드라이버는 Becker Series Drivers로 우리에게 잘 알려져  있다. 이 드라이버 중에는
패러랠 포트를 통해서 이더넷에 접근할 수 있게 해주는 D-Link 포켓 어댑터를 위한 드라이
버도 있다. 이러한 드라이버는 Bj rn Ekwall (bj0rn@blox.se)에 의해 만들어 졌다. DEPCA
드라이버는 David C. Davies (davies@wanton.lkg.dec.com)에 의해 만들어 졌다.
<P>
<H3>Ethernet Cabling</H3>

<P>만약 여러분이 일생에 딱 한번 이더넷을 설치하고자 한다면,  여기 케이블링이란 용어가 여
러분에게 적합할 것이다. 이더넷은 케이블링에 대해서는 매우 까다롭다. 이 케이블 양쪽  끝
레지스터는 50 옴(ohm)으로 맞추어져 있어야 하며, 여러분은 어떻게 해서든지  그것들을 분
기시켜 놓으면 안된다. (이를테면, 세 개의 케이블은 스타형(star-shape)으로 연결되어야 한
다. 만약 여러분이 T자 형태로 접합되어 있는 BNC 커넥터와  함께 얇은 동축 케이블을 사
용하고 있다면, 반드시 보드의 커넥터에 접합할 부분을 꼬아서 연결시켜야 한다.
<P>만약 여러분이 thicknet에 연결하려고 한다면, 반드시 트랜스시버를  거쳐서 여러분의 호
스트를 접촉시켜야 한다. (때때로 이것을 Ethernet Attachment Unit라고  부른다.) 여러분은
그 트랜스시버를 보드에 있는 15핀 AUI 포트에 꽂아넣고 실드 케이블을 사용할 수도 있다.
<P>
<H3>Supported Boards</H3>

<P>지원하고 있는 보드의 완전한 리스트를 볼려면 Ethernet HOWTO 문서를 참고하라. 이것은
매달
Paul Gortmaker. - <EM>Paul에게 문의할 사항이 있다면, gpg109@rsphysse.anu.edu.au로
연락하기 바란다.</EM> 에 의해 comp.os.linux.announce에 포스트되고 있다.
<P>여기에서 보는 목록들은 리눅스에서 지원하는 가장 널리  알려진 보드를 말해주고 있다.
실제로 HOWTO 목록에는 여기서 보는 것의  세배정도의 목록을 볼 수 있다.  이 목록에서
여러분이 가지고 있는 이더넷 보드를 찾으려고 한다면, HOWTO 문서를 보는편이 더 낫다.
이 문서에는 때때로 이러한 카드를  운영하는 중요한 세부항목들을 포함하는  경우도 있다.
DMA에 기초를 두고 있는 이더넷 보드는 Adaptec 1542 SCSI controller과 같은 DMA 채널
을 사용한다. 여러분이 이더넷 보드의 DMA 채널을 다른 것으로 바꾸어 놓지 않는한,  이더
넷 보드가 만들어내는 패킷 데이터가 위치하는 지역이 마음대로 변할수도 있다.
<DL>
<DT><B>3Com EtherLink</B><DD><P>3c503, 3c503/16, 3c507 그리고  3c509를 지원한다. 3c501도 지원하지
만
이것은 속도가 매우 느리다.
<DT><B>Novell Eagle  NE1000 과 NE2000 그리고 여러 가지 호환기종들.</B><DD><P>NE1500과 NE2100도
지원한다.
<DT><B>Western Digital</B><DD><P>SMC/WD8003과 WD8013 (SMC Elite와  SMC Elite   Plus와 같다.)
을
지원하며, SMC Elite 16 Ultra도 새롭게 지원하고 있다.
<DT><B>Hewlett Packard</B><DD><P>HP 27252, HP 27247B, 그리고 HP J2405A를 지원한다.
<DT><B>D-Link</B><DD><P>DE-600 포켓 어댑터, DE-100, DE-200 그리고 DE-220-T를 지원한다.
그리고, PCMCIA 카드. - <EM>다른 랩탑과 연관되어 tsx-11.mit.edu에 있는
packages/laptops에 올라오고 있다.</EM>인 DE-650-T를 위한 패치 킷도 있다.
<DT><B>DEC</B><DD><P>DE200 (32K/64K), DE202, DE100 그리고 DEPCA rev E를 지원한다.
<DT><B>Allied Teliesis</B><DD><P>AT1500과 AT1700을 지원한다.
</DL>
<P>리눅스에서 이러한 카드 중 하나를 사용하고자 한다면,  리눅스 배포본에 포함되어 있는
커널을 컴파일하여 사용할 수도 있다. 이러한 카드는 일반적으로 그에 해당하는 드라이버를
가지고 있다. 장기간 동안 사용하고자  한다면, 여러분이 실제로 필요한 드라이버를  커널에
포함시켜서 컴파일 하는 편이 더 낫다.
<P>
<H3>Ethernet Autoprobing</H3>

<P>부팅할 때, 이더넷 코드는 여러분의 보드를 지정된 지역에 놓으려고 할 것이다. 이  코드는
다음에 보이는 어드레스와 순서대로 카드를 검사할 것이다.
<P>오토프로빙 코드에는 두가지 한계가 있다.  그중 하나는 모든 보드를  적절히 인식할 수
없다는 것이다. 이것은 일반적인 보드의 호환기종과 WD80x3 보드에서 종종 발생하는 현상
이다. 두 번째 문제는 커널이 순간에 하나 이상의 보드를 오토프로브할 수 없다. 이러한  현
상은 여러분이 어떤 보드가 어떤 인터페이스를  제어하는지를 모르는 것과 같이 생각해  볼
수있다.
<P>만약 여러분이 하나이상의 보드를 사용하고 있거나, 오토프로브가 여러분의 보드를 감지
하는데에 실패했다면, 여러분은 반드시 카드의 베이스 어드레스와 이름을 커널에 명시해야
한다.
<P>Net-3에서, 이것을 수행하기 위해서는 두가지 다른 형태의 방법을  취할 수 있다. 그 중
한가지 방법으로는 커널 소스 코드에 있는  drivers/net/Space.c 파일 (드라이버에 대한 모
든 정보를 담고 있다.)에 특정 정보를 변경시키거나 추가시켜 주는 것이다. 여러분이 네트워
킹 코드에 익숙해 있다면 이 방법을 추천해  주고 싶다. 더 나은 방법으로는 부팅할 때,  이
정보를 커널에 제공하는 것이다. 만약  부트 시스템으로 lilo를 사용한다면,  lilo.conf 파일에
append 옵션을 명시해 둠으로써 커널에 있는 변수들을  그냥 지나칠 수 있다. 이더넷 장치
를 위한 정보를 커널에 명시하기 위해서는, 다음에 보이는 변수들을 없애줄 수 있다.
<PRE>
     ether=irq, base_addr, param1, param2, name
</PRE>
<P>처음 네 개의 변수들은 숫자로 되어  있는 반면에 마지막 변수는 장치명을 뜻하는  것이
다. 모든 숫자값들은 임의로 추가시킬 수 있다; 만약 그것들을 생략하거나 0으로 설정해 두
었다면, 커널은 그 장치를 검사함으로써, 그 값을 감지해내려 하거나 초기값을 사용할  것이
다.
<P>첫 번째 변수는 장치에 할당되어 있는 IRQ를 설정하는 부분이다. 초기값으로, 커널은 장
치의 IRQ 채널을 자동으로 감지할  것이다. 3c503 드라이버는 특별한  형태를 가지고 있다.
이것은 IRQ를 5, 9, 3, 4를 선택하고, 이 라인에서 사용하기 위한 보드를 구성한다.
<P>base_addr 변수는 보드에 I/O 베이스 어드레스값을 주는 역할을  한다; 위에서 봤던 어
드레스를 검사하기 위해서는 커널에 0이라는 값을 주어야 한다.
<P>나머지 두 개의 변수들은 다른 형태의 드라이버에서 다르게 사용될 수도 있다. WD80x3
과 같은 공유 메모리 보드를 사용하기 위해서는, 공유 메모리 지역의 시작과 끝 어드레스를
명시해 주어야 한다. 다른 카드는 대개 디버깅  정보를 설정하기 위해서 param1 변수를 사
용한다. 1부터 7까지의 숫자는 그 디버깅 정보의 수준이 증가하는 것을 나타낸다. 반면에  8
은 완전히 다른 역할을  한다; 0은 초기값을 의미한다.  3c503 드라이버는 내부 트랜스시버
(초기값) 또는 외부 트랜스시버 (숫자값은 1)를  선택하기 위해서 param2를 사용한다. 전자
는 보드에 붙어있는 BNC 커넥터를 사용하고, 후자는 AUI 포트를 사용한다.
<P>만약 여러분이 두 개의 이더넷 보드를 가지고 있다면, 리눅스를 자동감지해 주는 하나의
보드를 가질 수 있으며, lilo에서 두  번째 보드의 변수를 지나칠 수 있다.  그러나 여러분은
먼저 드라이버가 실제로 두 번째 보드를 찾는지 확인해야 한다. 그렇지 않으면, 또 다른  하
나가 전혀 등록되지 않는 현상이 발생할 수도  있다. 여러분은 lilo에 있는 reserve 옵션을
그냥 지나치게 함으로써 이러한 문제를 해결할 수 있다. 두 번째 보드에 주어진 I/O 영역의
감지를 피하기 위해서는 커널에 분명히 명시해 두어야 한다.
<P>이를테면, 여러분이 인터페이스가 eth1이고 어드레스 0x300에  있는 이더넷 보드를 리눅
스에 설치하고자 한다면, 여러분은 커널에 있는 다음과 같은 변수를 없애주어야 한다.
<PRE>
     reserve=0x300,32 ether=0,0x300,eth1
</PRE>
<P>reserve 옵션은 어떤 장치를 검사할 때, 보드의 I/O 영역에  접근하는 장치가 없는지를
확인한다. 여러분은 또한 eth0를 오토프로빙하는 작업을 무시해 버리기 위해서도 커널 변수
를 사용할 수 있다.
<PRE>
     reserve=0x340,32 ether=0,0x340,eth0
</PRE>
<P>완전히 오토프로빙을 해제하기 위해서는, 다음과 같은 변수를 base_addr에 명시해 줄 수 있
다.
<PRE>
     ether=0, -1, eth0
</PRE>
<P>
<H2><A NAME="ss3.5">3.5 The PLIP Driver</A>
</H2>

<P>PLIP, Parallel Line IP는 여러분이 두 대의 컴퓨터 만을  연결해서 네트워크를 구성하고자
할 때 사용하는 아주 값싼 방법이다. 이것은 패러랠 포트와 10kBps에서 20kBps까지의 속도
를 낼수 있는 특별한 케이블을 사용한다.
<P>PLIP는 원래 주식회사 Crynwr에서 제작한 것이다. 이것은  패러랠 포트를 사용하여 PC
에서 장시간동안 네트워크를 하기위해 만들어 졌으며, 단 방향 프린터 포트를 사용한다; 이
것은 PC에서 주변장치로 데이터를 보낼 때 단지 여덟 개의 데이터  라인만을 사용할 수 있
다. PLIP는 입력을 위해서 포트의 다섯가지 상태 라인만을 사용함으로써 이러한 작업을  수
행한다. 그리고 PLIP는 모든 데이터를 4비트씩 전송해야하는  제한 사항을 가지고 있다. 이
러한 운영 모드를 mode zero PLIP라고 부른다. 오늘날, 이러한 단 방향 포트는 더 이상  사
용되지 않고 있다. 그래서, mode 1이라고 부르는 PLIP 확장시킨 것이  나왔는데, 이것은 전
체 8비트 인터페이스를 사용하게끔 제작되었다.
<P>현재, 리눅스는 오직 mode 0만을  지원해 주고 있다. 이것은  PLIP의 초기 코드와는 그
성격이  판이하게  다르다.  지금은  Crynwr에서  수행하는   PLIP와  NCSA   telnet. -
<EM>NCSA
telnet는 이더넷 또는 PLIP를 통해 DOS에서 TCP</EM>IP를 구현해주는 특별한 프로그램이며,
telnet와 FTP를 지원해 주고 있다./에서 사용하는 PLIP 드라이버와 호환성을 갖도록
만들어내고 있는 추세이다. PLIP를 사용해서 두 대의 컴퓨터를 연결하기 위해서는, 몇
몇 가게에서  판매하고 있는  "Null Printer" 또는  "Turbo Laplink" 케이블과 같은
특별한 케이블을 사용해야 한다. 하지만 여러분 자신도 쉽게 이것을 만들 수 있다.
이것에 대한 자세한 사항은 부록 A에 소개하고 있다.
<P>리눅스에서 사용하는 PLIP 드라이버는 무수히 많은 사람들이 이루어낸 성과이다. 이것은
현재 Niibe Yutaka가 관리하고 있다. 만약 이 드라이버가 추가되어 있는 커널이 컴파일되어
있다면, 각 프린터 포트를 위한 네트워크 인터페이스가 설정되어 있을 것이다. plip0는 패러
랠 포트 lp0와 일치하며, plip1은 lp1과 일치한다. 포트에 인터페이스를 매핑하는  작업은 다
음과 같다;
<P>만약 여러분이 다른 방법으로 프린터  포트를 구성하고 있다면, 리눅스  커널 소스 또는
새로운 커널에 있는 drivers/net/Space.c에 있는 값을 변경시켜 주어야 한다.
<P>하지만 이러한 매핑작업으로 인해 평상시 사용하는 패러랠 포트를 사용할 수 있다는 의
미는 아니다. 일치하는 인터페이스가 구성되었을때만 PLIP 드라이버를 엑세스할 수 있다.
<P>
<H2><A NAME="ss3.6">3.6 The SLIP and PPP Drivers</A>
</H2>

<P>SLIP (<EM>Serial Line IP</EM>)와 PPP (<EM>Point-to-Point Protocol</EM>)은  시리얼 라인을 통해
서
IP 패킷을 보내는 프로토콜로 널리 알려져 있다. 리눅스에서는 인터넷에 여러분의 컴퓨터를
접근시키기위해 동적 SLIP 과 PPP연결을 제공해 주고 있다. 그래서 각 사용자에게
IP 연결을 제공해 주고 있다.
<P>SLIP와 PPP를 실행하기 위해서, 하드웨어 정보를 수정할 필요는  없다; 여러분은 어떤
시리얼 포트를 사용할 수 있다. 시리얼 포트 환경이  TCP/IP 네트워킹에 명시되어 있지 않
은 관계로 여러 장에서 이것에 대해 기술해 놓고 있다. 더 자세한 정보를 얻고 싶다면,  4장
을 참고하기바란다.
<P>
<HR>
<A HREF="NetAdminGuide-KLDP-4.html">다음</A>
<A HREF="NetAdminGuide-KLDP-2.html">이전</A>
<A HREF="NetAdminGuide-KLDP.html#toc3">차례</A>
</BODY>
</HTML>
